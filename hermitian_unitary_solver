import numpy as np
import matplotlib.pyplot as plt

# Set random seed for reproducibility (optional)
np.random.seed(0)

# Set matrix size
N = 10

# Generate a random complex matrix A
A = np.random.randn(N, N) + 1j * np.random.randn(N, N)

# Make it Hermitian: H = (A + Aâ€ )/2
H = (A + A.conj().T) / 2

# Diagonalize it (get eigenvalues)
eigvals_H = np.linalg.eigvalsh(H)  # eigvalsh is for Hermitian matrices

# Plot on the complex plane
plt.figure(figsize=(6, 6))
plt.scatter(eigvals_H.real, eigvals_H.imag, color='blue', label='Hermitian eigenvalues')
plt.axhline(0, color='gray', linestyle='--')
plt.axvline(0, color='gray', linestyle='--')
plt.title('Eigenvalues of a Hermitian Matrix')
plt.xlabel('Real part')
plt.ylabel('Imaginary part')
plt.grid(True)
plt.legend()
plt.axis('equal')
plt.show()

# Generate a random complex matrix
Z = np.random.randn(N, N) + 1j * np.random.randn(N, N)

# Use QR decomposition to get a unitary matrix
Q, R = np.linalg.qr(Z)

# Ensure it's truly unitary (optional: normalize phases)
D = np.diag(np.exp(1j * np.angle(np.diag(R))))
U = Q @ D

# Diagonalize it
eigvals_U = np.linalg.eigvals(U)

# Plot on the complex plane
plt.figure(figsize=(6, 6))
plt.scatter(eigvals_U.real, eigvals_U.imag, color='green', label='Unitary eigenvalues')
# Draw unit circle for reference
theta = np.linspace(0, 2 * np.pi, 300)
plt.plot(np.cos(theta), np.sin(theta), 'r--', label='Unit circle')
plt.axhline(0, color='gray', linestyle='--')
plt.axvline(0, color='gray', linestyle='--')
plt.title('Eigenvalues of a Unitary Matrix')
plt.xlabel('Real part')
plt.ylabel('Imaginary part')
plt.grid(True)
plt.legend()
plt.axis('equal')
plt.show()